{"version":3,"sources":["../../src/dispatcher/ActorAppDispatcher.js"],"names":[],"mappings":";;;;;;;;QAIgB,QAAQ,GAAR,QAAQ;QAIR,OAAO,GAAP,OAAO;QAYP,QAAQ,GAAR,QAAQ;QAmCR,aAAa,GAAb,aAAa;;;;AArD7B,IAAM,IAAI,GAAG,sBAAgB,CAAC;;AAEvB,SAAS,QAAQ,CAAC,QAAQ,EAAE;AACjC,SAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;CAChC;;AAEM,SAAS,OAAO,CAAC,GAAG,EAAE;AAC3B,SAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;CAC1B;;;;;;;;;;AAAA,AAUM,SAAS,QAAQ,CAAC,IAAI,EAAe;MAAb,MAAM,yDAAG,EAAE;;AACxC,MAAI,CAAC,IAAI,EAAE;AACT,UAAM,IAAI,KAAK,CAAC,6BAA6B,CAAC,CAAC;GAChD;;;;;AAAA,AAKD,MAAI,OAAO,CAAC,GAAG,CAAC,QAAQ,KAAK,YAAY,EAAE;;;;;AAKzC,QAAI,MAAM,CAAC,KAAK,EAAE;AAChB,aAAO,CAAC,KAAK,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KAC7B,MAAM;AACL,aAAO,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC;KAC5B;GACF;;AAED,MAAI,CAAC,QAAQ,YAAE,IAAI,EAAJ,IAAI,IAAK,MAAM,EAAE;;;AAAC,AAGjC,SAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM,EAAK;AACtC,QAAI,MAAM,CAAC,KAAK,EAAE;AAChB,YAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;KACtB,MAAM;AACL,aAAO,CAAC,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,CAAC;KACrD;GACF,CAAC,CAAA;CACH;;;;;AAAA,AAKM,SAAS,aAAa,CAAC,OAAO,EAAE,KAAK,EAAe;MAAb,MAAM,yDAAG,EAAE;MAC/C,OAAO,GAAuB,KAAK,CAAnC,OAAO;MAAE,OAAO,GAAc,KAAK,CAA1B,OAAO;MAAE,OAAO,GAAK,KAAK,CAAjB,OAAO;;AAEjC,UAAQ,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;AAC1B,SAAO,OAAO,CAAC,IAAI,CACjB,UAAA,QAAQ;WAAI,QAAQ,CAAC,OAAO,eAAM,MAAM,IAAE,QAAQ,EAAR,QAAQ,IAAE;GAAA,EACpD,UAAA,KAAK;WAAI,QAAQ,CAAC,OAAO,eAAM,MAAM,IAAE,KAAK,EAAL,KAAK,IAAE;GAAA,CAC/C,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;CACtC;;kBAEc,IAAI","file":"ActorAppDispatcher.js","sourcesContent":["import { Dispatcher } from 'flux';\n\nconst flux = new Dispatcher();\n\nexport function register(callback) {\n  return flux.register(callback);\n}\n\nexport function waitFor(ids) {\n  return flux.waitFor(ids);\n}\n\n// Some Flux examples have methods like `handleViewAction`\n// or `handleServerAction` here. They are only useful if you\n// want to have extra pre-processing or logging for such actions,\n// but I found no need for them.\n\n/**\n * Dispatches a single action.\n */\nexport function dispatch(type, action = {}) {\n  if (!type) {\n    throw new Error('You forgot to specify type.');\n  }\n\n  // In production, thanks to DefinePlugin in webpack.config.production.js,\n  // this comparison will turn `false`, and UglifyJS will cut logging out\n  // as part of dead code elimination.\n  if (process.env.NODE_ENV !== 'production') {\n    // Logging all actions is useful for figuring out mistakes in code.\n    // All data that flows into our application comes in form of actions.\n    // Actions are just plain JavaScript objects describing “what happened”.\n    // Think of them as newspapers.\n    if (action.error) {\n      console.error(type, action);\n    } else {\n      console.info(type, action);\n    }\n  }\n\n  flux.dispatch({type, ...action});\n\n  // Return response or error for chaining async actions\n  return new Promise((resolve, reject) => {\n    if (action.error) {\n      reject(action.error);\n    } else {\n      resolve(action.response ? action.response : action);\n    }\n  })\n}\n\n/**\n * Dispatches three actions for an async operation represented by promise.\n */\nexport function dispatchAsync(promise, types, action = {}) {\n  const { request, success, failure } = types;\n\n  dispatch(request, action);\n  return promise.then(\n    response => dispatch(success, {...action, response}),\n    error => dispatch(failure, {...action, error})\n  ).catch(console.error.bind(console));\n}\n\nexport default flux;\n"]}