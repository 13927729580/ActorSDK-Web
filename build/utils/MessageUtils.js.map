{"version":3,"sources":["../../src/utils/MessageUtils.js"],"names":[],"mappings":";;;QAEgB,e,GAAA,e;QAkBA,Y,GAAA,Y;QAQA,iB,GAAA,iB;QAKA,0B,GAAA,0B;;AAjChB;;AAEO,SAAS,eAAT,CAAyB,OAAzB,EAAkC,GAAlC,EAAuC,WAAvC,EAAoD,QAApD,EAA8D;AACnE,MAAI,QAAQ,MAAR,CAAe,IAAf,CAAoB,EAApB,KAA2B,GAA/B,EAAoC;AAClC,WAAO,iCAAc,OAArB;AACD;;AAED,MAAI,QAAQ,KAAR,IAAiB,QAAQ,KAAR,KAAkB,iCAAc,IAArD,EAA2D;AACzD,QAAI,QAAQ,QAAR,IAAoB,QAAxB,EAAkC;AAChC,aAAO,iCAAc,IAArB;AACD;;AAED,QAAI,QAAQ,QAAR,IAAoB,WAAxB,EAAqC;AACnC,aAAO,iCAAc,QAArB;AACD;AACF;;AAED,SAAO,QAAQ,KAAf;AACD;;AAEM,SAAS,YAAT,CAAsB,IAAtB,EAA4B;AACjC,SAAO,KACJ,IADI,GAEJ,KAFI,CAEE,IAFF,EAGJ,GAHI,CAGC,UAAC,IAAD;AAAA,kBAAe,IAAf;AAAA,GAHD,EAIJ,IAJI,CAIC,IAJD,CAAP;AAKD;;AAEM,SAAS,iBAAT,CAA2B,GAA3B,QAA8C;AAAA,MAAZ,QAAY,QAAZ,QAAY;;AACnD,MAAM,cAAc,SAAS,SAAS,MAAT,GAAkB,CAA3B,CAApB;AACA,SAAO,eAAe,QAAQ,YAAY,MAAZ,CAAmB,IAAnB,CAAwB,EAAtD;AACD;;AAEM,SAAS,0BAAT,CAAoC,QAApC,EAA8C,QAA9C,EAAwD,GAAxD,EAA6D;AAClE,MAAI,aAAa,CAAb,IAAkB,CAAC,SAAS,MAAhC,EAAwC;AACtC,WAAO,CAAC,CAAR;AACD;;AAED,MAAI,QAAQ,CAAC,CAAb;AACA,OAAK,IAAI,IAAI,SAAS,MAAT,GAAkB,CAA/B,EAAkC,GAAlC,EAAuC,KAAK,CAA5C,EAA+C;AAC7C,QAAM,UAAU,SAAS,CAAT,CAAhB;AACA,QAAI,QAAQ,QAAR,IAAoB,QAApB,IAAgC,QAAQ,MAAR,CAAe,IAAf,CAAoB,EAApB,KAA2B,GAA/D,EAAoE;AAClE,aAAO,KAAP;AACD;;AAED,YAAQ,CAAR;AACD;;;AAGD,SAAO,KAAP;AACD","file":"MessageUtils.js","sourcesContent":["import { MessageStates } from '../constants/ActorAppConstants';\n\nexport function getMessageState(message, uid, receiveDate, readDate) {\n  if (message.sender.peer.id !== uid) {\n    return MessageStates.UNKNOWN;\n  }\n\n  if (message.isOut && message.state === MessageStates.SENT) {\n    if (message.sortDate <= readDate) {\n      return MessageStates.READ;\n    }\n\n    if (message.sortDate <= receiveDate) {\n      return MessageStates.RECEIVED;\n    }\n  }\n\n  return message.state;\n}\n\nexport function quoteMessage(text) {\n  return text\n    .trim()\n    .split('\\n')\n    .map(((line) => `> ${line}`))\n    .join('\\n');\n}\n\nexport function isLastMessageMine(uid, { messages }) {\n  const lastMessage = messages[messages.length - 1];\n  return lastMessage && uid === lastMessage.sender.peer.id;\n}\n\nexport function getFirstUnreadMessageIndex(messages, readDate, uid) {\n  if (readDate === 0 || !messages.length) {\n    return -1;\n  }\n\n  let index = -1;\n  for (let i = messages.length - 1; i--; i >= 0) {\n    const message = messages[i];\n    if (message.sortDate <= readDate || message.sender.peer.id === uid) {\n      return index;\n    }\n\n    index = i;\n  }\n\n  // maybe unreachable\n  return index;\n}\n"]}